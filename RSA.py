#!/usr/bin/env python3

import base64
import binascii
from sympy.ntheory.factor_ import totient
from Crypto.Util.number import inverse

def main():
	
	e = 65537

	# p = 10428615258416108003372202871855627713663325599674460924186517713082197448534315449595394752587304354394402047262801959990727856908043138185588365886987557
	# q = 8849030739304056868757301096931487921973840186794195322071503751716059434197468028088264340322992996182734000877348221433845302801843370163430108727308579
	# n = q * p
	n = 257827703087398016057355158654193468564980243813004452658087616586210487667215030370871398983230710387803731676134007721137156696714627083072326445637415561591372586919746606752675050732692230618293581354674196658443898625965651230501721590806987488038754683843111434873697465691139129703835890867256688046172118591
	
	# phi = 133075794736862400686388110598570266808714052683651232655122797445099216964925703530068957607358890220696254013415564497625510160656547477386290353341301365877872031151018140890962539358215097403168452396402116271802269636497626498820406125901329433708704273662567430256232652048920492894069126553095462130720#(p-1)*(q-1)
	# phi = (q - 1)*(p - 1)
	phi = totient(n)
	
	d = inverse(e, phi)

	# c_str = "21389445315904"
	# c_int = int(c_str.encode().hex(), 16)
	c_int = 194667317703687479298989188290833629421904543231503224641743768867721632949682167895699280370759100055314992068135383846690184090232092994595979623784341194946153538127175310278245722299688212621004144260665233469561373125699948009903943019071999887294005117156960295183926108287198987970959145603429337056005819069

	m_int = pow(c_int, d, n)

	print(translete(m_int).decode())


def translete(m_int):
	try:
		m_bytes = binascii.unhexlify(hex(m_int)[2:])
	except binascii.Error:
		m_bytes = binascii.unhexlify('0'+hex(m_int)[2:])
	return m_bytes


def root(x, n):
    # Start with some reasonable bounds around the nth root.
    upper_bound = 1
    while upper_bound ** n <= x:
        upper_bound *= 2
    lower_bound = upper_bound // 2
    # Keep searching for a better result as long as the bounds make sense.
    while lower_bound < upper_bound:
        mid = (lower_bound + upper_bound) // 2
        mid_nth = mid ** n
        if lower_bound < mid and mid_nth < x:
            lower_bound = mid
        elif upper_bound > mid and mid_nth > x:
            upper_bound = mid
        else:
            # Found perfect nth root.
            return mid
    return mid + 1


if __name__ == '__main__':
    main()